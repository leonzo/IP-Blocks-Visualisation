<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>IP Ranges</title>
  <link rel="stylesheet" href="/style.css" type="text/css" media="screen" charset="utf-8">
  <script src="lib.js"></script>
</head>
<body>
  <!-- <a href="https://github.com/donovanhide/IP-Blocks-Visualisation"><img style="position: absolute; top: 0; right: 0; border: 0;" src="http://s3.amazonaws.com/github/ribbons/forkme_right_red_aa0000.png" alt="Fork me on GitHub" /></a> -->
  <div id="map">
    <svg id="world"></svg>
  </div>
  <div id="charts-right">
    <div id="country-chart" class="chart">
      <div class="title">Country</div>
    </div>
    <div id="year-chart" class="chart">
      <div class="title">Year</div>
    </div>
    <div id="a-chart" class="chart">
      <div class="title">Class A</div>
    </div>
    <div id="b-chart" class="chart">
      <div class="title">Class B</div>
    </div>
    <div id="c-chart" class="chart">
      <div class="title">Class C</div>
    </div>
    <div id="d-chart" class="chart">
      <div class="title">Class D</div>
    </div>
    <div id="length-chart" class="chart">
      <div class="title">Length</div>
    </div>
  </div>
  <div id="plot"></div>
  <script>
  var layers=new Array(256);
  for (i=0;i<256;i++){
    plot=document.getElementById("plot");
    canvas = document.createElement('canvas');  
    canvas.setAttribute('style','z-index: '+(255-i)+';margin-left:'+(i)+'px;margin-top:'+(255-i)+'px');
    canvas.setAttribute('class','layer');  
    canvas.setAttribute('width',256);  
    canvas.setAttribute('height',256);
    context=canvas.getContext("2d");  
    plot.appendChild(canvas); 
    layers[i]=context;
  }

  function setPixel(image,index){
    image.data[index+0] = 0x4D;
    image.data[index+1] = 0x87;
    image.data[index+2] = 0xB7;
    image.data[index+3] = 0xFF;    
  }

  function updateLayers(data){
    for (i=0;i<256;i++){
      imageData=layers[i].createImageData(256,256)
      if (data.hasOwnProperty(i)){
        for (j=0;j<data[i].length;j++){
          block=data[i][j];
          // Do Class B's
          for (x = block.b1; x<block.b2; x++) {
            for (y = block.c1; y<block.c2; y++) {
              setPixel(imageData,(x+y*256)*4);
            }
          }            
          //Do Class C's
          for (y = block.c1; y<block.c2; y++) {
            setPixel(imageData,(block.b1+y*256)*4);
          }
          // Do Class D's
          setPixel(imageData,(block.b1+block.c1*256)*4);
        }
      }
      layers[i].putImageData(imageData, 0, 0); 
    }
    console.log(data.length);
    d3.selectAll(".layer").style('opacity',0.5);
  }
  
  function updateMap(data){
    d3.selectAll('svg#world path').classed("selected",function(){return data.hasOwnProperty(this.id); });
  }
  
  d3.json("world-countries.json", function(collection) {
    var xy = d3.geo.mercator().translate([256, 256]).scale(512),
        path = d3.geo.path().projection(xy);
    d3.select("svg#world")
      .selectAll("path")
        .data(collection.features)
      .enter().append("svg:path")
        .attr("id",function(d){return d.id;})
        .attr("d", path);
  });
  
  d3.json("ips.json", function(json) {
    var nestByClass = d3.nest()
        .key(function(d){ return d.a})
        .sortValues(function(a,b){return a.i<b.i?-1:a.i>b.i?1:0;});
    var nestByCountry = d3.nest()
        .key(function(d){return json.countries[d.co]});
    var ips=[];
    counter=0;
    json.data.split("|").forEach(function(row, i) {
      cells=row.split(","),
      start=json.starts[parseInt(cells[0],16)]+counter,
      length=json.lengths[parseInt(cells[1],16)],
      counter=start+length,
      end=counter-1;
      ips.push({
        i: i,
        r: new Date(json.registrations[parseInt(cells[2],16)]*100000),
        co: parseInt(cells[3],16),
        a: (start&0xFF000000)>>>24,
        b1: (start&0x00FF0000)>>>16,
        b2: (end&0x00FF0000)>>>16,
        c1: (start&0x0000FF00)>>>8,
        c2: (end&0x0000FF00)>>>8,
        d1: start&0x000000FF,
        d2: end&0x000000FF,
        l: length
      });
    });
    
    // Create the tesseract and relevant dimensions and groups.
    ip = tesseract(ips);
    all = ip.groupAll();
    registered = ip.dimension(function(d) { return d.r; }),
    registrations = registered.group(function(d) {return d3.time.year(d);}),
    length = ip.dimension(function(d){return d.l;});
    lengths = length.group();//.reduceSum(function(d){return d.l});
    classA = ip.dimension(function(d){return d.a});
    classAs = classA.group();//.reduceSum(function(d){return d.l});
    classB = ip.dimension(function(d){return d.b1});
    classBs = classB.group();//.reduceSum(function(d){return d.l});
    classC = ip.dimension(function(d){return d.c1});
    classCs = classC.group();//.reduceSum(function(d){return d.l});
    classD = ip.dimension(function(d){return d.d1});
    classDs = classD.group();//.reduceSum(function(d){return d.l});
    country = ip.dimension(function(d){return d.co});
    countries = country.group();

    var charts = [
        barChart()
          .dimension(country)
          .group(countries)
        .x(d3.scale.linear()
          .domain(d3.extent(countries.all(),function(d){return d.key}))
          .range([0,270])),
        barChart()
          .dimension(registered)
          .group(registrations)
        .x(d3.time.scale()
          .domain([d3.min(registrations.all(),function(d){return d.key;}),new Date(2015,0,1)])
          .rangeRound([0,270])),
        barChart()
          .dimension(classA)
          .group(classAs)
        .x(d3.scale.linear()
          .domain([0,270])
          .range([0,270])),
        barChart()
          .dimension(classB)
          .group(classBs)
        .x(d3.scale.linear()
          .domain([0,270])
          .range([0,270])),
        barChart()
          .dimension(classC)
          .group(classCs)
        .x(d3.scale.linear()
          .domain([0,270])
          .range([0,270])),
        barChart()
          .dimension(classD)
          .group(classDs)
        .x(d3.scale.linear()
          .domain([0,270])
          .range([0,270])),
        barChart()
          .dimension(length)
          .group(lengths)
        .x(d3.scale.log()
          .domain(d3.extent(lengths.all(),function(d){return d.key;}))
          .range([0,270])
          .nice())
    ];

    // Given our array of charts, which we assume are in the same order as the
    // .chart elements in the DOM, bind the charts to the DOM and render them.
    // We also listen to the chart's brush events to update the display.
    var chart = d3.selectAll(".chart")
        .data(charts)
        .each(function(chart) { chart.on("brush", renderAll).on("brushend", renderAll); });

    // Render the initial lists.
    // var list = d3.selectAll(".list")
    //     .data([ipList]);

    // Render the total.
    // d3.selectAll("#total")
    //     .text(formatNumber(ip.size()));

    renderAll();

    // Renders the specified chart or list.
    function render(method) {
      d3.select(this).call(method);
    }

    // Whenever the brush moves, re-rendering everything.
    function renderAll() {
      chart.each(render);
      updateLayers(nestByClass.map(classA.top(Infinity)));
      updateMap(nestByCountry.map(country.top(Infinity)));
      // list.each(render);
      // d3.select("#active").text(formatNumber(all.value()));
    }

    window.filter = function(filters) {
      filters.forEach(function(d, i) { charts[i].filter(d); });
      renderAll();
    };

    window.reset = function(i) {
      charts[i].filter(null);
      renderAll();
    };

  });
  </script>
</body>
</html>